#if 0

第１７章　コピー

https://programming-place.net/ppp/contents/cpp/language/017.html

コピー
デフォルトで、代入演算子の使用や、関数に実引数を渡す（実引数が関数の仮引数にコピーされる）と、
実体のコピーが行われる。（新しくメモリーを確保し、複製を行う。）
ex) a = b; func(a); ...

関数に実引数を渡す際に、ポインタや参照を用いると余分なメモリーの確保が行われないので効率的になる。

一時オブジェクト
ソースコード上に直接的に記述されていない、名前のないオブジェクトのこと。
名前がないので、rvalue。

ex) 実体を返す関数の戻り値など

一時オブジェクトの破棄は、オブジェクトの生成を含んだ場所から「完全式」の最後となる。
ex) std::cout << echoA(); << std::endl; の std::endl; の終了部分。


「完全式」とは、他の式の一部になっていない式のこと。
破棄された一時オブジェクトへのアクセスは、未定義動作
「const参照」で参照された、rvalue は、その「const参照」が存在する限り破棄されないので、
（１）のような書き方ができる。
ポインタでは、受け取ることはできない。

代入演算子のオーバーロード
クラス型のオブジェクトの代入で、コピーを行う際に、
そのクラス型専用に定義された代入演算子が使用される。
デフォルトでは、コンパイラが自動的に生成した代入演算子が使用され、
メンバ１つ１つをコピーする挙動となっている。

この代入演算子は、クラスを定義する際に自分で定義することができる。（２）
このような、演算子の処理を定義することを「演算子オーバーロード」と呼ぶ。

「演算子オーバーロード」を行う場合は、
int型でできることは、できるようにする。できないことは、できないようにする。
といったセオリーに従って定義するのが良い。

ディープコピーの実現
「代入演算子のオーバーロード」は、
メンバ変数に、動的に確保されたメモリを指すポインタがある時に使用される場合がある。


#endif

#include <iostream>

// (2)
class	ClassA {
	public:
		ClassA& operator=(const ClassA& rhs);

	private:
};
// (2)
ClassA& ClassA::operator=(const ClassA& rhs)
{
	return (*this);
}

std::string	funcA()
{
	return ("hello");
}

int	main()
{
	// (1)
	const std::string	&str = funcA();
	std::cout << str << std::endl;

}

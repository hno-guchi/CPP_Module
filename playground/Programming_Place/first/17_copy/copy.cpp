#if 0

第１７章　コピー

https://programming-place.net/ppp/contents/cpp/language/017.html

コピー
デフォルトで、代入演算子の使用や、関数に実引数を渡す（実引数が関数の仮引数にコピーされる）と、
実体のコピーが行われる。（新しくメモリーを確保し、複製を行う。）
ex) a = b; func(a); ...

関数に実引数を渡す際に、ポインタや参照を用いると余分なメモリーの確保が行われないので効率的になる。

一時オブジェクト
ソースコード上に直接的に記述されていない、名前のないオブジェクトのこと。
名前がないので、rvalue。

ex) 実体を返す関数の戻り値など

一時オブジェクトの破棄は、オブジェクトの生成を含んだ場所から「完全式」の最後となる。
ex) std::cout << echoA(); << std::endl; の std::endl; の終了部分。


「完全式」とは、他の式の一部になっていない式のこと。
破棄された一時オブジェクトへのアクセスは、未定義動作
「const参照」で参照された、rvalue は、その「const参照」が存在する限り破棄されないので、
（１）のような書き方ができる。
ポインタでは、受け取ることはできない。

代入演算子のオーバーロード
クラス型のオブジェクトの代入で、コピーを行う際に、
そのクラス型専用に定義された代入演算子が使用される。
デフォルトでは、コンパイラが自動的に生成した代入演算子が使用され、
メンバ１つ１つをコピーする挙動となっている。

この代入演算子は、クラスを定義する際に自分で定義することができる。（２）
このような、演算子の処理を定義することを「演算子オーバーロード」と呼ぶ。

「演算子オーバーロード」を行う場合は、
int型でできることは、できるようにする。できないことは、できないようにする。
といったセオリーに従って定義するのが良い。

ディープコピーの実現
「代入演算子のオーバーロード」は、メンバ変数に、動的に確保されたメモリを指すポインタがある時に使用される場合がある。
デフォルトの代入演算子の挙動だと、以前に指していたアドレスの領域をdeleteせずに、新しいアドレスを渡してしまう。
また、ポインタが示す先のデータをコピーするのではなく、ポインタ自体をコピーするので、同じアドレスを指すポインタ変数が２つになってしまう。

自己代入
「自己代入」とは「a = a」のように、自分自身へ自分をコピーすること。
チェック処理は、書いても書かなくとも良い。（３）

copy constructor
既存のオブジェクトを複製する。
代入演算子が、既に生成されているオブジェクトに、メンバ変数などのコピーを行うのに対して、コピーコンストラクタは、オブジェクトの生成から行う点が異なる。
また、代入演算子の場合、コピー先が既に持っている情報を、適切に解放する処理が必要。
値の変更を行う必要がないので、仮引数に「const」を付けるのが一般的。

#endif

#include <iostream>

// (2)
class	ClassA {
	public:
		ClassA& operator=(const ClassA& rhs);

	private:
		int	value;
};
// (2)
ClassA& ClassA::operator=(const ClassA& rhs)
{
	// (3)
	if (this == &rhs) {
		return (*this);
	}
	this->value = rhs.value;
	return (*this);
}

std::string	funcA()
{
	return ("hello");
}

int	main()
{
	// (1)
	const std::string	&str = funcA();
	std::cout << str << std::endl;

}

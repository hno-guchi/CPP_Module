#if 0

第１９章　演算子のオーバーロード

https://programming-place.net/ppp/contents/cpp/language/019.html

演算子オーバーロード
クラス定義の中にメンバ関数の定義を書く方法について説明する。

関係演算子、等価演算子
戻り値がbool型のconstメンバ関数で定義するのが一般的。
==演算子をオーバーロードした場合、必ず!=演算子もオーバーロードすること。
!=演算子のオーバーロードは、対称性を確保するために以下のような実装にすると良い。（１）
[== , !=] [<, >=] [>, <=] は、それぞれ対応する。

算術演算子
クラス外で定義するのが良い。
constメンバ関数として定義する。
引数は、自身と同じクラス型のconst参照
戻り値は、自身と同じクラス型の実体
ローカル変数を用意し、計算結果を格納する。

単項演算子

インクリメント、デクリメント
前置と後置の区別を付ける必要がある。（後置には、引数(int 0)を渡してやることで、区別できる。）
前置は、自身のメンバ変数をインクリメントし、自身の参照を返す。(2)
後置は、自身のオブジェクトを複製してから、インクリメントを行い、複製したオブジェクトの実体を返す。(3)
このとき後置インクリメントでは、前置インクリメントを呼び出すように実装すると処理内容による食い違いを避け、保守性を上げることができる。


#endif

// (1)
bool	classA::operator!=(const classA& rhs)
{
	return (!(*this == rhs));
}

// (2)
classA&	classA::operator++()
{
	++this->value_;
	return (*this);
}

// (3)
const classA	classA::operator++(int)
{
	const classA	old(*this);
	++(*this);
	return (old);
}
